"use strict";const s=require("electron"),T=require("path"),o=require("better-sqlite3"),y=require("fs"),h=require("crypto");function N(t,e,a){const n=f(t,e);return g(n,a)}function f(t,e){const a=Buffer.from(e,"base64");return h.privateDecrypt({key:t,padding:h.constants.RSA_PKCS1_OAEP_PADDING,oaepHash:"sha256"},a).toString("base64")}function g(t,e){const r=Buffer.from(t,"base64"),l=Buffer.from(e,"base64"),p=l.subarray(0,12),A=l.subarray(l.length-16),E=l.subarray(12,l.length-16),d=h.createDecipheriv("aes-256-gcm",r,p);d.setAuthTag(A),d.setAutoPadding(!1);let b=d.update(E,void 0,"utf8");return b+=d.final("utf8"),b}const c=T.join(s.app.getPath("userData"),"./wallets.db"),R=process.env.NODE_ENV==="development";let i=null;function u(){i=new s.BrowserWindow({width:1200,height:800,title:"Beaver Payment",icon:T.join(__dirname,"../src/assets/favicon.ico"),webPreferences:{nodeIntegration:!0,contextIsolation:!0,preload:T.join(__dirname,"preload.js")}}),R?(i.loadURL("http://localhost:5173"),i.webContents.openDevTools()):i.loadFile(T.join(__dirname,"../dist/index.html"))}s.app.whenReady().then(()=>{try{const t=new o(c);console.log("数据库连接成功"),t.transaction(e=>{e.run(`
                CREATE TABLE IF NOT EXISTS wallets (
                    address TEXT PRIMARY KEY,
                    encryptedPrivateKey TEXT NOT NULL,
                    encryptedAesKey TEXT NOT NULL,
                    chainType TEXT NOT NULL,
                    uid TEXT NOT NULL,
                    createdAt TEXT NOT NULL,
                    updatedAt TEXT NOT NULL
                )
            `)}),t.close()}catch(t){console.error("数据库连接失败",t)}u(),s.app.on("activate",()=>{s.BrowserWindow.getAllWindows().length===0&&u()})});s.app.on("window-all-closed",()=>{process.platform!=="darwin"&&s.app.quit()});s.ipcMain.on("openPrivateKeyFileDialog",t=>{i?s.dialog.showOpenDialog(i,{properties:["openFile"],filters:[{name:"Private Key",extensions:["pem"]}]}).then(e=>{if(!e.canceled&&e.filePaths.length>0){const a=y.readFileSync(e.filePaths[0],"utf8");t.reply("selectedPrivateKeyFile",a)}else t.reply("selectedPrivateKeyFile",null)}).catch(e=>{console.error("Error in openPrivateKeyFileDialog:",e),t.reply("selectedPrivateKeyFile",null)}):(console.error("mainWindow is null"),t.reply("selectedPrivateKeyFile",null))});s.ipcMain.on("getWallets",(t,e)=>{const a=new o(c);try{L(a),O(a);const n=a.prepare("SELECT * FROM wallets WHERE chainType = ?").all(e);for(const r of n){const l=a.prepare("SELECT * FROM wallet_balance WHERE address = ?").all(r.address);r.balances=l}t.reply("getWallets",n)}catch(n){console.error("Error in getWallets:",n),t.reply("getWallets",[])}finally{a.close()}});s.ipcMain.on("getWalletByAddress",(t,e)=>{const a=new o(c),n=a.prepare("SELECT * FROM wallets WHERE address = ?").get(e);a.close(),t.reply("getWalletByAddress",n)});s.ipcMain.on("getWalletByAddressWithPrivateKey",(t,{address:e,adminPrivateKey:a})=>{const n=new o(c),r=n.prepare("SELECT * FROM wallets WHERE address = ?").get(e);n.close();const l=N(a,r.encryptedAesKey,r.encryptedPrivateKey);t.reply("getWalletByAddressWithPrivateKey",r,l)});s.ipcMain.on("getWalletsPage",(t,e,a,n)=>{const r=new o(c),l=r.prepare("SELECT * FROM wallets WHERE chainType = ? LIMIT ? OFFSET ?").all(e,n,(a-1)*n),p=r.prepare("SELECT COUNT(*) FROM wallets WHERE chainType = ?").get(e);r.close(),t.reply("getWalletsPage",l,p)});s.ipcMain.on("getWalletBalanceByChainIdAndContractAddressAndBalanceMoreThan",(t,{chainId:e,contractAddress:a,balance:n})=>{if(!a||!n){console.error("Missing contractAddress or balance"),t.reply("getWalletBalanceByChainIdAndContractAddressAndBalanceMoreThan",[],{total:0});return}const r=new o(c),l=r.prepare("SELECT * FROM wallet_balance WHERE chainId = ? AND contractAddress = ? AND balance >= ?").all(e,a,n);for(const E of l){const d=r.prepare("SELECT balance FROM wallet_balance WHERE chainId = ? AND contractAddress = ? AND address = ?").get(E.chainId,"",E.address);d&&(E.ethBalance=BigInt(d.balance))}const p=r.prepare("SELECT COUNT(*) AS total FROM wallet_balance WHERE chainId = ? AND contractAddress = ? AND balance >= ?").get(e,a,n),A=r.prepare("SELECT SUM(balance) AS total FROM wallet_balance WHERE chainId = ? AND contractAddress = ? AND balance >= ?").get(e,a,n);r.close(),t.reply("getWalletBalanceByChainIdAndContractAddressAndBalanceMoreThan",l,p,A)});s.ipcMain.on("getEthBalanceByChainIdAndAddress",(t,e)=>{const a=new o(c),n=a.prepare("SELECT balance FROM wallet_balance WHERE chainId = ? AND contractAddress = ?").get(e,"");a.close(),t.reply("getEthBalanceByChainIdAndAddress",n)});s.ipcMain.on("sumWalletBalanceByChainId",(t,e)=>{const a=new o(c),n=a.prepare("SELECT SUM(balance) FROM wallet_balance WHERE chainId = ?").get(e);a.close(),t.reply("sumWalletBalanceByChainId",n)});s.ipcMain.on("sumWalletBalanceByChainIdAndContractAddress",(t,e)=>{const a=new o(c),n=a.prepare("SELECT contractAddress, SUM(balance) FROM wallet_balance WHERE chainId = ? GROUP BY contractAddress").all(e);a.close(),t.reply("sumWalletBalanceByChainIdAndContractAddress",n)});s.ipcMain.on("saveWallets",(t,e)=>{const a=new o(c);try{L(a),a.transaction(n=>{e.forEach(r=>{n.prepare("SELECT 1 FROM wallets WHERE address = ?").get(r.address)||n.prepare("INSERT INTO wallets (address, encryptedPrivateKey, encryptedAesKey, chainType, uid, createdAt, updatedAt) VALUES (?, ?, ?, ?, ?, ?, ?)").run(r.address,r.encryptedPrivateKey,r.encryptedAesKey,r.chainType,r.uid,new Date().toISOString(),new Date().toISOString())})})(a)}catch(n){console.error("Error in saveWallets:",n)}finally{a.close()}});s.ipcMain.on("saveOrUpdateWalletBalance",(t,e)=>{new o(c).prepare("INSERT OR REPLACE INTO wallet_balance (address, chainId, contractAddress, balance, lastCollectedAt, lastRefreshedAt) VALUES (?, ?, ?, ?, ?, ?)").run(e.address,e.chainId,e.contractAddress,e.balance,e.lastCollectedAt,e.lastRefreshedAt),t.reply("saveOrUpdateWalletBalance",e)});s.ipcMain.on("saveWalletBalances",(t,e)=>{const a=new o(c);try{e.forEach(n=>{a.prepare("INSERT OR REPLACE INTO wallet_balance (address, chainId, contractAddress, balance, lastCollectedAt, lastRefreshedAt) VALUES (?, ?, ?, ?, ?, ?)").run(n.address,n.chainId,n.contractAddress,n.balance.toString(),n.lastCollectedAt,n.lastRefreshedAt)}),t.reply("saveWalletBalances",e)}catch(n){console.error("Error saving wallet balances:",n)}finally{a.close()}});s.ipcMain.on("backupDatabase",(t,e)=>{const a=new o(c);C(a,e),a.close(),t.reply("backupDatabase","Database backup completed")});s.ipcMain.on("listBackupFiles",(t,e)=>{const a=y.readdirSync(e);t.reply("listBackupFiles",a)});s.ipcMain.on("readFile",(t,e)=>{const a=y.readFileSync(e.path,"utf8");t.reply("readFile",a)});function L(t){t.prepare(`
        CREATE TABLE IF NOT EXISTS wallets (
            address TEXT PRIMARY KEY,
            encryptedPrivateKey TEXT NOT NULL,
            encryptedAesKey TEXT NOT NULL,
            chainType TEXT NOT NULL,
            uid TEXT NOT NULL,
            createdAt TEXT NOT NULL,
            updatedAt TEXT NOT NULL
        )
    `).run()}function O(t){t.prepare(`
        CREATE TABLE IF NOT EXISTS wallet_balance (
            address TEXT NOT NULL,
            chainId TEXT NOT NULL,
            contractAddress TEXT NOT NULL,  
            balance TEXT NOT NULL,
            lastCollectedAt TEXT NOT NULL,
            lastRefreshedAt TEXT NOT NULL,
            PRIMARY KEY (address, chainId, contractAddress)
        )
    `).run()}function C(t,e){const a=new Date().toISOString().replace(/[-:Z]/g,"").replace(/\.\d{3}/,""),n=T.join(e,`./wallets.db.backup.${a}`);y.copyFileSync(c,n)}
